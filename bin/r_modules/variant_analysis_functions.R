#!/usr/bin/env Rscript 
# Script containing functions for loading and analysis of data from Envision, SIFT, FoldX, Polyphen2 & EVCouplings

#### General Functions ####
# Generate a per position mutational profile for a given study (i.e. enrichment ratio of all substitutions at a position)
# dm_data is a list object of a dms study, as generated by load_variant_data.R.
# Any numerical score column in dm_data$single_variants can be converted to a profile matrix
make_var_matrix <- function(dm_data, score='score', single_only=FALSE){
  if (!score %in% names(dm_data$single_variants)) {
    return(NULL)
  }
  
  if (single_only & "multi_variant" %in% class(dm_data)){
    return(NULL)
  }
  
  variants <- select(dm_data$single_variants, variants, score=!!score) %>%
    mutate(wt = str_sub(variants, end=1),
           mut = str_sub(variants, start=-1),
           pos = as.integer(str_sub(variants, start=2, end=-2))) %>%
    select(-variants)
  
  if ('=' %in% variants$mut){
    variants$mut[variants$mut=='='] <- variants$wt[variants$mut=='=']
  }
  
  variants <- spread(variants, key = 'mut', value = 'score') %>%
    arrange(pos) %>%
    select(pos, wt, A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y)
  
  return(variants)
}

# Impute missing values in variant profiles matrix
# impute function is applied to each subsititution type (e.g. A->C) accross all 
# positions in each study to build a per study profile
impute_variant_profiles <- function(variant_matrix, background_matrix=NULL, impute_function=median){
  # Per study/per AA median mutational profiles
  if (is.null(background_matrix)){
    background_matrix <- variant_matrix
  }
  per_study_mean_profiles <- select(background_matrix, study, pos, wt, A:Y) %>%
    group_by(study, wt) %>%
    summarise_at(.vars = vars(-pos), .funs = impute_function, na.rm=TRUE) %>%
    replace(is.na(.), 0)
  
  # Matrix of mutational profiles with missing values imputed from the per study/AA medians
  imputed_matrix <- gather(variant_matrix, key='mut', value='score', A:Y) %>%
    left_join(., gather(per_study_mean_profiles, key='mut', value='imp_score', A:Y), by = c("study", 'mut', 'wt'))
  
  imputed_matrix$score[is.na(imputed_matrix$score)] <- imputed_matrix$imp_score[is.na(imputed_matrix$score)]
  
  imputed_matrix <- imputed_matrix %>%
    select(-imp_score) %>%
    spread(key=mut, value=score)
  
  return(imputed_matrix)
}

# Count the number of unique values in each column of a tibble
col_unique_counts <- function(tbl){
  return(apply(tbl, 2, function(x){length(unique(x))}))
}

# Wrapper to deal with different/no structures for studies
make_foldx_var_matrix <- function(dm_data){
  if (identical(NA, dm_data$dm$pdb_id)){
    return(NULL)
  }
  
  pdb_ids <- str_split(dm_data$dm$pdb_id, ':', simplify = TRUE)[,1]
  
  variants <- sapply(pdb_ids, function(x){make_var_matrix(dm_data, score=str_c('foldx_', x, '_ddG'))}, simplify = FALSE) %>%
    bind_rows(.id='pdb_id') %>%
    group_by(pos, wt) %>%
    summarise_at(.vars = vars(-pdb_id), .funs = mean) %>%
    ungroup() %>%
    arrange(pos)
  
  return(variants)
}
########

#### Score distribution plots ####
# Plot study histograms
plot_study_histogram <- function(tbl, thresh_tbl=NULL, x='score', fill='authour', facet='~study', thresh='thresh'){
  p <- ggplot(tbl, aes_string(x=x, fill='authour')) + 
    geom_histogram() +
    facet_wrap(facet, scales = 'free') +
    xlab(MUT_SCORE_NAME) +
    ylab('Count')
  
  if(!is.null(thresh_tbl)){
    p <- p + geom_vline(aes_string(xintercept=thresh), data = thresh_tbl, colour='red')
  }
  
  return(p)
}

# Plot factor frequencies
plot_factor_density <- function(tbl, facet, x='norm_score', col='authour'){
  p <- ggplot(tbl, aes_string(x=x, colour=col)) + 
    geom_density(trim=TRUE) +
    facet_wrap(facet, scales = 'free') +
    xlab(MUT_SCORE_NAME) +
    ylab('Density') +
    scale_color_discrete()
  
  return(p)
}

# Plot distribution of enrichment score along length of proteins
# Expects a tibble with columns pos and score, 
# with optional column study from which title is derived if unique and not specified
plot_score_distribution_per_position <- function(tbl, title=NULL){
  if (is.null(title)){
    if ('study' %in% names(tbl) & col_unique_counts(tbl)['study'] == 1){
      title <- unique(tbl$study)
    } else {
      title = ''
    }
  }
  
  p <- ggplot(tbl, aes(group=pos, x=pos, y=score)) +
    geom_boxplot() +
    xlab('AA Position') + 
    ylab(MUT_SCORE_NAME) +
    ggtitle(title)
  
  return(p)
}
########

#### PCA of position profiles ####
# Generate PCA of mutational profiles
positional_profile_PCA <- function(variant_matrix){
  pca <- prcomp(as.matrix(select(variant_matrix, A:Y)), center = TRUE, scale. = TRUE)
  pca_variants <- bind_cols(select(variant_matrix, -(A:Y)), as_tibble(pca$x))
  
  return(list(variants=pca_variants, pca=pca))
}

basic_pca_plots <- function(pca){
  plots <- list()
  plots$all_pcs <- labeled_ggplot(
    ggarrange(
      plotlist = lapply(
        seq(1, 19, 2),
        function(x){
          ggplot(pca$variants, aes_string(x=str_c('PC', x), y=str_c('PC', x + 1), colour='wt')) + 
            geom_point()
        }),
      nrow = 2, ncol = 5, common.legend = TRUE, legend = 'right'
    ),
    width = 20, height = 15
  )
    
  
  plots$by_authour <- ggplot(pca$variants, aes(x=PC1, y=PC2, colour=gene_name)) + 
    facet_wrap(~study) +
    geom_point()
  
  plots$secondary_structure <- labeled_ggplot(
    ggarrange(
      plotlist = lapply(
        seq(1, 19, 2),
        function(x){
          ggplot(pca$variants, aes_string(x=str_c('PC', x), y=str_c('PC', x + 1), colour='sec_struct')) + 
            geom_point()
        }),
      nrow = 2, ncol = 5, common.legend = TRUE, legend = 'right'
    ),
    width = 20, height = 15
  )
  
  plots$fields_group_studies <- ggplot(filter(pca$variants,
                                              authour %in% c('Araya et al.', 'Melamed et al.', 'Starita et al.',
                                                             'Kitzman et al.', 'Weile et al.')),
                                       aes(x=PC1, y=PC2, colour=study)) +
    geom_point()
  
  plots$position_sig <- ggplot(pca$variants, aes(x=PC1, y=PC2, colour=sig_count)) +
    geom_point()
  
  plots$by_aa <- ggplot(pca$variants, aes(x=PC1, y=PC2, colour=gene_name)) + 
    facet_wrap(~wt) +
    geom_point()
  
  plots$surface_accesibility <- ggplot(pca$variants, aes(x=PC1, y=PC2, colour=all_atom_rel)) +
    geom_point() +
    scale_colour_gradientn(colours = c('blue', 'green', 'yellow', 'orange', 'red'))
  
  return(plots)
}

get_avg_aa_pca_profile <- function(pca){
  avg_profile <- pca$variants %>%
      group_by(wt) %>%
      summarise_at(.vars = vars(starts_with('PC')), .funs = list(~ mean(.)))
  
  cor_mat <- select(avg_profile, -wt) %>% 
    t() %>% 
    set_colnames(avg_profile$wt) %>%
    cor()
  
  aa_order <- rownames(cor_mat)[hclust(dist(cor_mat))$order]
  
  cor_tbl <- cor_mat %>%
    as_tibble(rownames = 'AA1') %>%
    gather(key = 'AA2', value = 'cor', -AA1) %>%
    mutate(AA1 = factor(AA1, levels = aa_order),
           AA2 = factor(AA2, levels = aa_order))
  
  return(list(avg_profile=avg_profile, cor_mat=cor_mat, cor_tbl=cor_tbl, aa_order=aa_order))
}

pca_surf_acc_cor <- function(pca){
  variants <- drop_na(pca$variants, all_atom_abs:polar_rel)
  
  variant_mat <- select(variants, starts_with('PC')) %>% 
    as.matrix()
  
  surface_acc_mat <- select(variants, all_atom_abs:polar_rel) %>% 
    as.matrix()
  
  cor_mat <- cor(variant_mat, surface_acc_mat)
  
  cor_tbl <- cor_mat %>%
    as_tibble(rownames = 'PC') %>%
    gather(key = 'Surf', value = 'cor', -PC) %>%
    mutate(PC = factor(PC, levels = str_c('PC', 1:dim(cor_mat)[1])))
  
  return(list(tbl=cor_tbl, matrix=cor_mat))
}

aa_avg_profile_plot <- function(x){list(avg_aa_profile=ggplot(x$avg_profile, aes(x=PC1, y=PC2, label=wt)) + geom_text())}

aa_profile_heatmap <- function(pca){list(
  aa_profile_heatmap=ggplot(pca$cor_tbl, aes(x=AA1, y=AA2, fill=cor)) + 
    geom_tile(colour='white') + 
    scale_fill_gradient2() +
    theme(axis.ticks = element_blank(), panel.background = element_blank())
)}

pca_surface_heatmap <- function(pca){list(
  pc_surf_acc_heatmap=ggplot(pca$tbl, aes(x=PC, y=Surf, fill=cor)) + 
    geom_tile(colour='white') + 
    scale_fill_gradient2() +
    theme(axis.ticks = element_blank(), panel.background = element_blank())
)}

per_aa_pcas <- function(aa, variant_matrix){
  variant_matrix <- filter(variant_matrix, wt == aa)
  
  profile_pca <- positional_profile_PCA(variant_matrix)
  surface_cor <- pca_surf_acc_cor(profile_pca)
  
  basic_plots <- basic_pca_plots(profile_pca)
  surface_heatmap <- pca_surface_heatmap(surface_cor)
  
  return(c(basic_plots, pc_surface_acc_heatmap=surface_heatmap))
}
########

#### SIFT/FoldX comparison ####
# compute pairwise distance between positions within each gene
compute_per_gene_pairwise_profile_dists <- function(variants, score_name='dist'){
  dists <- variants %>%
    group_by(study) %>%
    do(compute_pairwise_mut_profile_dists(., score_name))
  return(dists)
}

# Compute pairwise distances between profiles in a tbl. Expects columns A:Y with per residue substitution scores
compute_pairwise_mut_profile_dists <- function(variants, score_name='dist'){
  dists <- variants %>%
    select(A:Y) %>%
    as.matrix() %>%
    set_rownames(variants %>% unite(col='id', pos, wt, sep='-') %>% pull(id)) %>%
    dist() %>%
    as.matrix() %>%
    as_tibble(rownames = 'var1') %>%
    gather('var2', !!score_name, -var1) %>%
    separate(var1, c('pos1', 'aa1'), sep='-') %>%
    separate(var2, c('pos2', 'aa2'), sep='-')
  return(dists)
}

########

#### Secondary Structure ####
plot_secondary_structure_profile <- function(tbl, a_helix_propensity=NULL){
  # AH Positional profile
  ah_pos_avg <- group_by(tbl, alpha_helix_position) %>%
    summarise_at(.vars = vars(A:Y), .funs = mean, na.rm=TRUE) %>%
    gather(key = 'mut', value = 'score', -alpha_helix_position)
  
  p_ah_pos_profile <- ggplot(filter(ah_pos_avg, alpha_helix_position < 20),
                 aes(x=alpha_helix_position, y=mut, fill=score)) +
    geom_tile() +
    scale_fill_gradient2()
  
  # AH Propensity Plot
  if (!is.null(a_helix_propensity)){
    ah_avg_profile <- filter(tbl, !is.na(alpha_helix)) %>%
      select(A:Y) %>%
      gather(key = 'mut', value = 'score') %>%
      group_by(mut) %>%
      summarise(mean = mean(score, na.rm=TRUE),
                sd = sd(score, na.rm = TRUE),
                n = sum(!is.na(score))) %>%
      left_join(., select(a_helix_propensity, mut = aa1, exptl), by='mut')
    
    p_ah_propensity <- ggplot(ah_avg_profile, aes(x = mean, y = exptl, label = mut)) +
      geom_text() +
      geom_smooth(method = 'lm') +
      xlab('Avg Mutant Enrichment Score') + 
      ylab('Experimental Helix Propensity')
  } else {
    p_ah_propensity <- NULL
  }
  
  # AH Substitution Matrix
  ah_mat <- filter(tbl, !is.na(alpha_helix)) %>%
    gather(key = 'mut', value = 'score', A:Y) %>%
    select(study, pos, wt, mut, score) %>%
    group_by(wt, mut) %>%
    summarise(score = mean(score, na.rm=TRUE))
  
  p_ah_subs_mat <- ggplot(ah_mat, aes(x=wt, y=mut, fill=score)) +
    geom_tile() +
    scale_fill_gradient2()
  
  # BS Positional Profile
  bs_mat <- group_by(tbl, beta_sheet_position) %>%
    summarise_at(.vars = vars(A:Y), .funs = mean, na.rm=TRUE) %>%
    gather(key = 'mut', value = 'score', -beta_sheet_position)
    
  
  p_bs_pos_profile <- ggplot(filter(bs_mat, beta_sheet_position < 9), aes(x=beta_sheet_position, y=mut, fill=score)) +
    geom_tile() +
    scale_fill_gradient2()
  
  # BS Substitution Matrix
  bs_mat <- filter(tbl, !is.na(beta_sheet)) %>%
    gather(key = 'mut', value = 'score', A:Y) %>%
    select(study, pos, wt, mut, score) %>%
    group_by(wt, mut) %>%
    summarise(score = mean(score, na.rm=TRUE))
  
  p_bs_subs_mat <- ggplot(bs_mat, aes(x=wt, y=mut, fill=score)) +
    geom_tile() +
    scale_fill_gradient2()
  
  return(list(alpha_helix_profile = p_ah_pos_profile,
              alpha_helix_propensity = p_ah_propensity,
              alpha_helix_substitution_matrix = p_ah_subs_mat,
              beta_sheet_profile = p_bs_pos_profile,
              beta_sheet_substitution_matrix = p_bs_subs_mat))
}

plot_alpha_helix_dist_plots <- function(tbl, seq_intervals=5){
  ah_tbl <- select(tbl, alpha_helix, alpha_helix_position, pos, wt, A:Y) %>%
    drop_na(alpha_helix) %>%
    mutate(alpha_helix_angle = mod((alpha_helix_position - 1) * 100, 360)) %>%
    group_by(alpha_helix) %>%
    do(get_ah_distances(.))
  
  cut_size <- max(ah_tbl$seq_dist) / seq_intervals
  ah_tbl <- mutate(ah_tbl,
                   seq_dist_cut = cut(seq_dist, breaks = seq_intervals, labels = FALSE)*cut_size-cut_size/2)
  
  p_angle <- ggplot(ah_tbl, aes(x=angle_dist, y=profile_dist)) +
    geom_violin(aes(group=angle_dist, fill=..n..)) +
    geom_smooth(method = 'lm') +
    xlab('Angular Distance') +
    ylab('Enrichment Profile Distance')
  
  p_seq_point <- ggplot(ah_tbl, aes(x=seq_dist, y=profile_dist, colour=angle_dist)) +
    geom_point() +
    geom_smooth(method = 'lm') +
    xlab('Sequence Distance') +
    ylab('Enrichment Profile Distance')
  
  p_seq_viol <- ggplot(ah_tbl, aes(x=seq_dist, y=profile_dist)) +
    geom_violin(aes(x=seq_dist_cut, group=seq_dist_cut, fill=..n..), scale = 'width') +
    geom_smooth(method = 'lm') +
    xlab('Sequence Distance') +
    ylab('Enrichment Profile Distance')
  
  return(list(angular_dist_vs_profile_dist = p_angle,
              seq_dist_vs_profile_dist = p_seq_point,
              seq_dist_vs_profile_dist_viol = p_seq_viol))
}

# Calculate distances between enrichment profiles and angular distances for all positions within an a-helix
get_ah_distances <- function(tbl){
  prof_dists <- select(tbl, A:Y) %>%
    as.matrix() %>%
    dist(method = 'manhattan')
  
  angle_dists <- select(tbl, alpha_helix_angle) %>%
    as.matrix() %>%
    dist(method = 'manhattan')
  
  helix_len <- dim(tbl)[1]
  dists <- tibble(pos1 = rep(1:helix_len, helix_len),
                  pos2 = rep(1:helix_len, each=helix_len)) %>%
    filter(pos1 != pos2, pos1 > pos2) %>%
    mutate(profile_dist = prof_dists[helix_len*(pos2-1) - pos2*(pos2-1)/2 + pos1 - pos2],
           angle_dist = angle_dists[helix_len*(pos2-1) - pos2*(pos2-1)/2 + pos1 - pos2],
           angle_dist = pmin(angle_dist, abs(360 - angle_dist)),
           seq_dist = pos1 - pos2)
  
  return(dists)
}

plot_beta_sheet_orientation <- function(tbl){
  bs_tbl <- filter(tbl, !is.na(beta_sheet)) %>%
    select(study, pos, wt, beta_sheet, beta_sheet_position, A:Y) %>%
    group_by(beta_sheet) %>%
    do(get_bs_cors(.))
  
  p_bs_side_cor <- ggplot(bs_tbl, aes(x = same_side, y = cor)) +
    geom_boxplot()
  
  return(p_bs_side_cor)
}

get_bs_cors <- function(tbl){
  select(tbl, A:Y) %>%
    as.matrix() %>%
    t() %>%
    cor(use = 'pairwise.complete.obs') %>%
    set_colnames(str_c('V', 1:dim(.)[2])) %>%
    as_tibble(.name_repair = 'unique') %>%
    mutate(pos1 = 1:dim(.)[1]) %>%
    gather(key = 'pos2', value = 'cor', -pos1) %>%
    mutate(pos2 = as.integer(str_sub(pos2, 2)),
           side1 = mod(pos1, 2),
           side2 = mod(pos2, 2),
           same_side = side1 == side2) %>%
    filter(pos2 < pos1) %>%
    return()
}



# Label secondary structure on variant profile matrices
label_secondary_structure <- function(tbl){
  tbl <- group_by(tbl, study) %>%
      mutate(region = split_protein_regions(pos)) %>%
      group_by(study, region) %>%
      mutate(beta_sheet = find_secondary_structures(sec_struct, target='E', prefix = str_c(first(study), '_', first(region), '_')),
             alpha_helix = find_secondary_structures(sec_struct, target='H', prefix = str_c(first(study), '_', first(region), '_'))) %>%
      group_by(beta_sheet) %>%
      mutate(beta_sheet_position = 1:n()) %>%
      group_by(alpha_helix) %>%
      mutate(alpha_helix_position = 1:n()) %>%
      ungroup()
  tbl$alpha_helix_position[is.na(tbl$alpha_helix)] <- NA
  tbl$beta_sheet_position[is.na(tbl$beta_sheet)] <- NA
  
  return(tbl)
}

# Find simple secondary structure runs
find_secondary_structures <- function(x, target='E', min_length=4, prefix=NULL){
  runs <- rle(x)
  target_runs <- runs$values == target & runs$lengths >= min_length
  
  final_runs <- rep(NA, length(target_runs))
  final_runs[target_runs] <- 1:sum(target_runs)
  final_runs <- rep(final_runs, times = runs$lengths)
  
  if (!is.null(prefix)){
    final_runs <- str_c(prefix, final_runs)
  }
  
  return(final_runs)
}

# Find continuous regions with data
split_protein_regions <- function(pos){
  reg_ends <- which(c(diff(pos) > 1, TRUE))
  reg_labels <- rep(1:length(reg_ends), times=c(reg_ends[1], diff(reg_ends)))
  return(reg_labels)
}

########