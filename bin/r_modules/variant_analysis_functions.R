#!/usr/bin/env Rscript 
# Script containing functions for loading and analysis of data from Envision, SIFT, FoldX, Polyphen2 & EVCouplings

#### General Functions ####
# Generate a per position mutational profile for a given study (i.e. enrichment ratio of all substitutions at a position)
# dm_data is a list object of a dms study, as generated by load_variant_data.R.
# Any numerical score column in dm_data$single_variants can be converted to a profile matrix
make_var_matrix <- function(dm_data, score='score'){
  if (!score %in% names(dm_data$single_variants)) {
    return(NULL)
  }
  
  variants <- select(dm_data$single_variants, variants, score=!!score) %>%
    mutate(wt = str_sub(variants, end=1),
           mut = str_sub(variants, start=-1),
           pos = as.integer(str_sub(variants, start=2, end=-2))) %>%
    select(-variants)
  
  if ('=' %in% variants$mut){
    variants$mut[variants$mut=='='] <- variants$wt[variants$mut=='=']
  }
  
  variants <- spread(variants, key = 'mut', value = 'score') %>%
    arrange(pos) %>%
    select(pos, wt, A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y)
  
  return(variants)
}

# Impute missing values in variant profiles matrix
# impute function is applied to each subsititution type (e.g. A->C) accross all 
# positions in each study to build a per study profile
impute_variant_profiles <- function(variant_matrix, background_matrix=NULL, impute_function=median){
  # Per study/per AA median mutational profiles
  if (is.null(background_matrix)){
    background_matrix <- variant_matrix
  }
  per_study_mean_profiles <- select(background_matrix, study, pos, wt, A:Y) %>%
    group_by(study, wt) %>%
    summarise_at(.vars = vars(-pos), .funs = impute_function, na.rm=TRUE) %>%
    replace(is.na(.), 0)
  
  # Matrix of mutational profiles with missing values imputed from the per study/AA medians
  imputed_matrix <- gather(variant_matrix, key='mut', value='score', A:Y) %>%
    left_join(., gather(per_study_mean_profiles, key='mut', value='imp_score', A:Y), by = c("study", 'mut', 'wt'))
  
  imputed_matrix$score[is.na(imputed_matrix$score)] <- imputed_matrix$imp_score[is.na(imputed_matrix$score)]
  
  imputed_matrix <- imputed_matrix %>%
    select(-imp_score) %>%
    spread(key=mut, value=score)
  
  return(imputed_matrix)
}

# Count the number of unique values in each column of a tibble
col_unique_counts <- function(tbl){
  return(apply(tbl, 2, function(x){length(unique(x))}))
}

# Wrapper to deal with different/no structures for studies
make_foldx_var_matrix <- function(dm_data){
  if (is.null(dm_data$dm$pdb_id)){
    return(NULL)
  }
  
  pdb_ids <- str_split(dm_data$dm$pdb_id, ':', simplify = TRUE)[,1]
  
  variants <- sapply(pdb_ids, function(x){make_var_matrix(dm_data, score=str_c('foldx_', x, '_ddG'))}, simplify = FALSE) %>%
    bind_rows(.id='pdb_id') %>%
    group_by(pos, wt) %>%
    summarise_at(.vars = vars(-pdb_id), .funs = mean) %>%
    ungroup() %>%
    arrange(pos)
  
  return(variants)
}
########

#### Score distribution plots ####
# Plot study histograms
plot_study_histogram <- function(tbl, thresh_tbl=NULL, x='score', fill='authour', facet='~study', thresh='thresh'){
  p <- ggplot(tbl, aes_string(x=x, fill='authour')) + 
    geom_histogram() +
    facet_wrap(facet, scales = 'free') +
    xlab(MUT_SCORE_NAME) +
    ylab('Count')
  
  if(!is.null(thresh_tbl)){
    p <- p + geom_vline(aes_string(xintercept=thresh), data = thresh_tbl, colour='red')
  }
  
  return(p)
}

# Plot factor frequencies
plot_factor_density <- function(tbl, facet, x='norm_score', col='authour'){
  p <- ggplot(tbl, aes_string(x=x, colour=col)) + 
    geom_density(trim=TRUE) +
    facet_wrap(facet, scales = 'free') +
    xlab(MUT_SCORE_NAME) +
    ylab('Density') +
    scale_color_discrete()
  
  return(p)
}

# Plot distribution of enrichment score along length of proteins
# Expects a tibble with columns pos and score, 
# with optional column study from which title is derived if unique and not specified
plot_score_distribution_per_position <- function(tbl, title=NULL){
  if (is.null(title)){
    if ('study' %in% names(tbl) & col_unique_counts(tbl)['study'] == 1){
      title <- unique(tbl$study)
    } else {
      title = ''
    }
  }
  
  p <- ggplot(tbl, aes(group=pos, x=pos, y=score)) +
    geom_boxplot() +
    xlab('AA Position') + 
    ylab(MUT_SCORE_NAME) +
    ggtitle(title)
  
  return(p)
}
########

#### PCA of position profiles ####
# Generate PCA of mutational profiles
positional_profile_PCA <- function(variant_matrix){
  pca <- prcomp(as.matrix(select(variant_matrix, A:Y)), center = TRUE, scale. = TRUE)
  pca_variants <- bind_cols(select(variant_matrix, -(A:Y)), as_tibble(pca$x))
  
  return(list(variants=pca_variants, pca=pca))
}

basic_pca_plots <- function(pca){
  plots <- list()
  plots$by_authour <- ggplot(pca$variants, aes(x=PC1, y=PC2, colour=gene_name)) + 
    facet_wrap(~study) +
    geom_point()
  
  plots$fields_group_studies <- ggplot(filter(pca$variants,
                                              authour %in% c('Araya et al.', 'Melamed et al.', 'Starita et al.',
                                                             'Kitzman et al.', 'Weile et al.')),
                                       aes(x=PC1, y=PC2, colour=study)) +
    geom_point()
  
  plots$position_sig <- ggplot(pca$variants, aes(x=PC1, y=PC2, colour=sig_count)) +
    geom_point()
  
  plots$by_aa <- ggplot(pca$variants, aes(x=PC1, y=PC2, colour=gene_name)) + 
    facet_wrap(~wt) +
    geom_point()
  
  plots$surface_accesibility <- ggplot(pca$variants, aes(x=PC1, y=PC2, colour=all_atom_rel)) +
    geom_point() +
    scale_colour_gradientn(colours = c('blue', 'green', 'yellow', 'orange', 'red'))
  
  return(plots)
}

get_avg_aa_pca_profile <- function(pca){
  avg_profile <- pca$variants %>%
      group_by(wt) %>%
      summarise_at(.vars = vars(starts_with('PC')), .funs = list(~ mean(.)))
  
  cor_mat <- select(avg_profile, -wt) %>% 
    t() %>% 
    set_colnames(avg_profile$wt) %>%
    cor()
  
  aa_order <- rownames(cor_mat)[hclust(dist(cor_mat))$order]
  
  cor_tbl <- cor_mat %>%
    as_tibble(rownames = 'AA1') %>%
    gather(key = 'AA2', value = 'cor', -AA1) %>%
    mutate(AA1 = factor(AA1, levels = aa_order),
           AA2 = factor(AA2, levels = aa_order))
  
  return(list(avg_profile=avg_profile, cor_mat=cor_mat, cor_tbl=cor_tbl, aa_order=aa_order))
}

pca_surf_acc_cor <- function(pca){
  variants <- drop_na(pca$variants, all_atom_abs:polar_rel)
  
  variant_mat <- select(variants, starts_with('PC')) %>% 
    as.matrix()
  
  surface_acc_mat <- select(variants, all_atom_abs:polar_rel) %>% 
    as.matrix()
  
  cor_mat <- cor(variant_mat, surface_acc_mat)
  
  cor_tbl <- cor_mat %>%
    as_tibble(rownames = 'PC') %>%
    gather(key = 'Surf', value = 'cor', -PC) %>%
    mutate(PC = factor(PC, levels = str_c('PC', 1:dim(cor_mat)[1])))
  
  return(list(tbl=cor_tbl, matrix=cor_mat))
}

aa_avg_profile_plot <- function(x){list(avg_aa_profile=ggplot(x$avg_profile, aes(x=PC1, y=PC2, label=wt)) + geom_text())}

aa_profile_heatmap <- function(pca){list(
  aa_profile_heatmap=ggplot(pca$cor_tbl, aes(x=AA1, y=AA2, fill=cor)) + 
    geom_tile(colour='white') + 
    scale_fill_gradient2() +
    theme(axis.ticks = element_blank(), panel.background = element_blank())
)}

pca_surface_heatmap <- function(pca){list(
  pc_surf_acc_heatmap=ggplot(pca$tbl, aes(x=PC, y=Surf, fill=cor)) + 
    geom_tile(colour='white') + 
    scale_fill_gradient2() +
    theme(axis.ticks = element_blank(), panel.background = element_blank())
)}

per_aa_pcas <- function(aa, variant_matrix){
  variant_matrix <- filter(variant_matrix, wt == aa)
  
  profile_pca <- positional_profile_PCA(variant_matrix)
  surface_cor <- pca_surf_acc_cor(profile_pca)
  
  basic_plots <- basic_pca_plots(profile_pca)
  surface_heatmap <- pca_surface_heatmap(surface_cor)
  
  return(c(basic_plots, pc_surface_acc_heatmap=surface_heatmap))
}
########