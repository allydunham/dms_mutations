#!/usr/bin/env Rscript 
# Functions for parsing and processing deep mutational scanning data for mutation analysis

# Generate a per position mutational profile for a given study (i.e. enrichment ratio of all substitutions at a position)
# dm_data is a list object of a dms study, as generated by load_variant_data.R.
# Any numerical score column in dm_data$single_variants can be converted to a profile matrix
make_var_matrix <- function(dm_data, score='score', single_only=FALSE){
  if (!score %in% names(dm_data$single_variants)) {
    return(NULL)
  }
  
  if (single_only & "multi_variant" %in% class(dm_data)){
    return(NULL)
  }
  
  variants <- select(dm_data$single_variants, variants, score=!!score) %>%
    mutate(wt = str_sub(variants, end=1),
           mut = str_sub(variants, start=-1),
           pos = as.integer(str_sub(variants, start=2, end=-2))) %>%
    select(-variants)
  
  if ('=' %in% variants$mut){
    variants$mut[variants$mut=='='] <- variants$wt[variants$mut=='=']
  }
  
  variants <- spread(variants, key = 'mut', value = 'score') %>%
    arrange(pos) %>%
    select(pos, wt, A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y)
  
  return(variants)
}

# Impute missing values in variant profiles matrix
# impute function is applied to each subsititution type (e.g. A->C) accross all 
# positions in each study to build a per study profile
impute_variant_profiles <- function(variant_matrix, background_matrix=NULL, impute_function=median){
  # Per study/per AA median mutational profiles
  if (is.null(background_matrix)){
    background_matrix <- variant_matrix
  }
  per_study_mean_profiles <- select(background_matrix, study, pos, wt, A:Y) %>%
    group_by(study, wt) %>%
    summarise_at(.vars = vars(-pos), .funs = impute_function, na.rm=TRUE) %>%
    replace(is.na(.), 0)
  
  # Matrix of mutational profiles with missing values imputed from the per study/AA medians
  imputed_matrix <- gather(variant_matrix, key='mut', value='score', A:Y) %>%
    left_join(., gather(per_study_mean_profiles, key='mut', value='imp_score', A:Y), by = c("study", 'mut', 'wt'))
  
  imputed_matrix$score[is.na(imputed_matrix$score)] <- imputed_matrix$imp_score[is.na(imputed_matrix$score)]
  
  imputed_matrix <- imputed_matrix %>%
    select(-imp_score) %>%
    spread(key=mut, value=score)
  
  return(imputed_matrix)
}

# Wrapper to deal with different/no structures for studies
make_foldx_var_matrix <- function(dm_data){
  if (identical(NA, dm_data$dm$pdb_id)){
    return(NULL)
  }
  
  pdb_ids <- str_split(dm_data$dm$pdb_id, ':', simplify = TRUE)[,1]
  
  variants <- sapply(pdb_ids, function(x){make_var_matrix(dm_data, score=str_c('foldx_', x, '_ddG'))}, simplify = FALSE) %>%
    bind_rows(.id='pdb_id') %>%
    group_by(pos, wt) %>%
    summarise_at(.vars = vars(-pdb_id), .funs = mean) %>%
    ungroup() %>%
    arrange(pos)
  
  return(variants)
}

# compute pairwise distance between positions within each gene
compute_per_gene_pairwise_profile_dists <- function(variants, score_name='dist'){
  dists <- variants %>%
    group_by(study) %>%
    do(compute_pairwise_mut_profile_dists(., score_name))
  return(dists)
}

# Compute pairwise distances between profiles in a tbl. Expects columns A:Y with per residue substitution scores
compute_pairwise_mut_profile_dists <- function(variants, score_name='dist'){
  dists <- variants %>%
    select(A:Y) %>%
    as.matrix() %>%
    set_rownames(variants %>% unite(col='id', pos, wt, sep='-') %>% pull(id)) %>%
    dist() %>%
    as.matrix() %>%
    as_tibble(rownames = 'var1') %>%
    gather('var2', !!score_name, -var1) %>%
    separate(var1, c('pos1', 'aa1'), sep='-') %>%
    separate(var2, c('pos2', 'aa2'), sep='-')
  return(dists)
}